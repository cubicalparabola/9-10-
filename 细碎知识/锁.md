1.**互斥锁**：互斥锁用于控制多个线程对他们之间共享资源互斥访问的一个信号量。也就是说是为了避免多个线程在某一时刻同时操作一个共享资源。在C++中，通过构造std::mutex的实例创建互斥元，调用成员函数lock()来锁定它，调用unlock()来解锁

2.**条件锁**：条件锁就是所谓的条件变量，某一个线程因为某个条件为满足时可以使用条件变量使改程序处于阻塞状态。一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程

3.**自旋锁**：自旋锁是一种busy-waiting的锁。也就是说，如果T1正在使用自旋锁，而T2也去申请这个自旋锁，此时T2肯定得不到这个自旋锁。与互斥锁相反的是，此时运行T2的处理器core2会一直不断地循环检查锁是否可用（自旋锁请求），直到获取到这个自旋锁为止。

4.**读写锁**：读写锁允许多个读者同时访问共享数据，但在写者访问共享数据时，所有其他尝试访问该数据（无论读取还是写入）的线程都将被阻塞，直到写者完成写入

5.**递归锁**：递归锁允许同一个线程多次获得同一个锁，而不会导致死锁
