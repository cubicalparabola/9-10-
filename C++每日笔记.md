1. 互斥锁：互斥锁用于控制多个线程对他们之间共享资源互斥访问的一个信号量。也就是说是为了避免多个线程在某一时刻同时操作一个共享资源。在C++中，通过构造std::mutex的实例创建互斥元，调用成员函数lock()来锁定它，调用unlock()来解锁
2. 条件锁：条件锁就是所谓的条件变量，某一个线程因为某个条件为满足时可以使用条件变量使改程序处于阻塞状态。一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程
3. 自旋锁：自旋锁是一种busy-waiting的锁。也就是说，如果T1正在使用自旋锁，而T2也去申请这个自旋锁，此时T2肯定得不到这个自旋锁。与互斥锁相反的是，此时运行T2的处理器core2会一直不断地循环检查锁是否可用（自旋锁请求），直到获取到这个自旋锁为止。
4. 读写锁：读写锁允许多个读者同时访问共享数据，但在写者访问共享数据时，所有其他尝试访问该数据（无论读取还是写入）的线程都将被阻塞，直到写者完成写入
5. 递归锁：递归锁允许同一个线程多次获得同一个锁，而不会导致死锁

1. 递归锁它允许同一个线程对同一互斥量多次加锁，而不会产生死锁。这是因为递归锁使用了引用计数机制，只有当加锁和解锁的次数相等时，锁才能被其他线程获取。
2. 定时互斥锁是一种特殊的互斥锁，它允许线程在尝试获取锁时设置一个超时时间。这意味着，如果线程在指定的时间内无法获取到锁，那么它将停止等待并继续执行其他操作
3. 递归定时互斥锁是C++标准库中的一个类，它允许同一个线程多次获取同一个互斥量，而不会导致死锁。
4. 共享互斥锁是C++17中引入的一个新特性，它允许多个读者线程同时访问共享数据，但在写者线程访问数据时会阻止其他线程（无论读者还是写者）访问数据
5. 共享定时互斥锁是C++14中引入的一个新特性，它允许多个读者线程同时访问共享数据，但在写者线程访问数据时会阻止其他线程（无论读者还是写者）访问数据。
